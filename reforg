#!/usr/bin/env python3

import argparse
import json
import re
import shutil
import subprocess
import sys
from enum import Enum, auto
from pathlib import Path
from typing import Any, Dict, Iterable, List, NamedTuple, Optional, Pattern, Tuple

#: Application version.
__version__ = "0.0.2"


######################
## DATA DEFINITIONS ##
######################


class Config(NamedTuple):
    """
    Program configuration.
    """

    #: Copy rules.
    rules: List["Rule"]

    #: Ignore patterns.
    ignores: List[Pattern[str]]

    #: Root directory to copy files to.
    root: Path

    #: Preserve metadata?
    metadata: bool

    #: Force overwrite?
    force: bool

    #: Dry run?
    dryrun: bool

    #: Are we on a terminal?
    terminal: bool

    #: Directories to traverse:
    dirs: List[Path]


class Rule(NamedTuple):
    """
    Copy rule.
    """

    #: Original filename pattern.
    regex: Pattern[str]

    #: Target filename template.
    template: str

    #: Sub directory for the target file.
    directory: str

    #: Process to run, if any.
    process: Optional["Process"]


class Process(NamedTuple):
    """
    External process to run.
    """

    #: Pipe input file via STDIN?
    stdin: bool

    #: Pipe output via STDOUT?
    stdout: bool

    #: Command to run with arguments.
    command: List[str]

    def run(self, context: Dict[str, str], source: Path, target: Path) -> None:
        """
        Runs the command.
        """
        ## Process arguments:
        command = [i.format(**context, source=source, target=target) for i in self.command]

        ## Define stdin, if any:
        stdin: Any = source.open("rb") if self.stdin else None

        ## Define stdout, if any:
        stdout: Any = target.open("wb") if self.stdout else subprocess.PIPE

        ## Defines stderr:
        stderr: Any = subprocess.STDOUT

        ## Run the process:
        print(
            f"[DEBUG] Running command (stdin={self.stdin}, stdout={self.stdout}): ", command,
        )
        subprocess.run(command, check=True, stdin=stdin, stdout=stdout, stderr=stderr)


class TColor:
    """
    Terminal colors.
    """

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


class Status(Enum):
    """
    Copy status indication.
    """

    DRYRUN = auto()
    EXISTS = auto()
    COPIED = auto()
    FORCED = auto()


##################################
## CLI ARGUMENTS PARSER HELPERS ##
##################################


def existingdir(x: str) -> Path:
    """
    Ensures an existing directory.
    """
    path = Path(x)

    if not (path.exists() and path.is_dir()):
        raise ValueError(f"{x} is not an existing directory.")

    return path


def compile_rules(rules: List[Dict[str, str]], prefix: str) -> List[Rule]:
    """
    Compiles copy rules.
    """
    return [
        Rule(
            re.compile(prefix + r["regex"]),
            r["filename"],
            r["directory"],
            compile_process(r.get("process")),
        )
        for r in rules
    ]


def compile_process(x: Any) -> Optional[Process]:
    """
    Attempts to compile the process, if any.
    """
    if not x or not x["command"]:
        return None

    return Process(
        stdin=x.get("stdin", True),
        stdout=x.get("stdout", True),
        command=[str(i) for i in x["command"]],
    )


def parse_cli_arguments() -> Config:
    """
    Parses and return arguments.
    """
    ## Define the parser:
    parser = argparse.ArgumentParser(
        prog=f"reforg",
        description="Organize files based on regular expressions",
        epilog=f"reforg -- v{__version__}",
    )

    ## Add specification file:
    parser.add_argument(
        "--spec",
        metavar="SPEC-FILE",
        required=True,
        type=argparse.FileType("r"),
        help="Specification file",
    )

    ## Add root firectory to clone files to:
    parser.add_argument(
        "--root",
        metavar="ROOT-DIR",
        required=True,
        type=existingdir,
        help="Root directory to copy processed files to",
    )

    ## Add dry-run:
    parser.add_argument("--dry-run", action="store_true", help="Dry run (do not copy anything)")

    ## Add flag to preserve metadata:
    parser.add_argument("--metadata", action="store_true", help="Preserve metadata while copying")

    ## Add flag to force copy:
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force copy if target exists (overwrite existing files)",
    )

    ## Add directories to traverse
    parser.add_argument(
        "dirs",
        metavar="DIR",
        type=existingdir,
        nargs="+",
        help=(
            "Directory to list files of to process. "
            "Note that special entries in the directory and sub-directories "
            "are not listed and therefore not processed."
        ),
    )

    ## Parse arguments:
    args = parser.parse_args()

    ## Load the spec file:
    spec = json.load(args.spec)

    ## Build config and return:
    return Config(
        rules=compile_rules(spec.get("rules", []), spec.get("prefix", "")),
        ignores=[re.compile(i) for i in spec.get("ignore", [])],
        root=args.root,
        force=args.force,
        metadata=args.metadata,
        dryrun=args.dry_run,
        dirs=args.dirs,
        terminal=sys.stdout.isatty(),
    )


###############
## WORKHORSE ##
###############


def classify(config: Config, path: Path) -> Optional[Tuple[Rule, Dict[str, str], Path]]:
    """
    Attempts to classify the given path as per given patterns.
    """
    ## Get and trim filename:
    filename = path.name

    ## Iterate over rules:
    for rule in config.rules:
        ## Attempt to match:
        match = rule.regex.match(filename)

        ## If we have a match, get groups, skip otherwise:
        if match:
            ## Yep, we have a match:
            groups = match.groupdict()

            ## Attempt to compile the target filename:
            try:
                newfilename = rule.template.format(**groups)
                directory = Path(rule.directory.format(**groups))
            except KeyError as err:
                print(err)
                print(path)
                raise err

            ## Build and return the target path:
            return rule, groups, config.root / directory / newfilename

    ## We do not have any match, return None:
    return None


def is_ignored(ignores: List[Pattern[str]], filename: str) -> bool:
    for ignore in ignores:
        if ignore.match(filename):
            return True
    return False


def traverse(config: Config) -> Iterable[Path]:
    """
    Traverses directories and yields paths of regular files.
    """
    for pdir in config.dirs:
        for path in (i for i in pdir.iterdir() if i.is_file()):
            if is_ignored(config.ignores, path.name):
                continue
            yield path


def print_term(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a terminal.
    """
    print(
        f"{TColor.WARNING}{status.name} {TColor.OKBLUE}{orig}{TColor.ENDC} -> {TColor.OKGREEN}{copy}{TColor.ENDC}"
    )


def print_nonterm(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a non-terminal.
    """
    print(f"{status.name} {orig} -> {copy}")


def do_copy_with_metadata(context: Dict[str, str], source: Path, target: Path) -> None:
    shutil.copy2(str(source), str(target))


def do_copy_without_metadata(context: Dict[str, str], source: Path, target: Path) -> None:
    shutil.copy(str(source), str(target))


def copier(config: Config, rule: Rule, context: Dict[str, str], orig: Path, copy: Path) -> None:
    """
    Attempts to copy the file.
    """
    if config.dryrun:
        status = Status.DRYRUN
    else:
        ## Get the copier function:
        if rule.process:
            copier = rule.process.run
        elif config.metadata:
            copier = do_copy_with_metadata
        else:
            copier = do_copy_with_metadata

        ## Get the target parent directory:
        parent = copy.parent

        ## Create parent directory if it does not exist:
        parent.mkdir(parents=True, exist_ok=True)

        ## Check whether target exists, and copy accordingly:
        if copy.exists() and config.force:
            copier(context, orig, copy)
            status = Status.FORCED
        elif copy.exists():
            status = Status.EXISTS
        else:
            copier(context, orig, copy)
            status = Status.COPIED

    ## Log it:
    if config.terminal:
        print_term(orig, copy, status)
    else:
        print_nonterm(orig, copy, status)


################
## ENTRYPOINT ##
################


def main() -> None:
    """
    Entrypoint.
    """
    ## Parse config:
    config = parse_cli_arguments()

    ## Attempt to classify each path:
    for path in traverse(config):
        ## Attempt to classify:
        attempt = classify(config, path)

        ## Success?
        if attempt is None:
            raise Exception(f"Path could not be classified. Filename: {path.name}")

        ## Get rule, context and target path:
        rule, context, target = attempt

        ## Copy:
        copier(config, rule, context, path, target)


if __name__ == "__main__":
    main()
