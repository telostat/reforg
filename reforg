#!/usr/bin/env python3

import argparse
import json
import re
import shutil
import sys
from enum import Enum, auto
from pathlib import Path
from typing import Dict, Iterable, List, NamedTuple, Optional, Pattern

#: Application version.
__version__ = "0.0.1.dev0"


######################
## DATA DEFINITIONS ##
######################


class Config(NamedTuple):
    """
    Program configuration.
    """

    #: Copy rules.
    rules: List["Rule"]

    #: Ignore patterns.
    ignores: List[Pattern[str]]

    #: Root directory to copy files to.
    root: Path

    #: Preserve metadata?
    metadata: bool

    #: Force overwrite?
    force: bool

    #: Dry run?
    dryrun: bool

    #: Are we on a terminal?
    terminal: bool

    #: Directories to traverse:
    dirs: List[Path]


class Rule(NamedTuple):
    """
    Copy rule.
    """

    #: Original filename pattern.
    regex: Pattern[str]

    #: Target filename template.
    template: str

    #: Sub directory for the target file.
    directory: str


class TColor:
    """
    Terminal colors.
    """

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


class Status(Enum):
    """
    Copy status indication.
    """

    DRYRUN = auto()
    EXISTS = auto()
    COPIED = auto()
    FORCED = auto()


##################################
## CLI ARGUMENTS PARSER HELPERS ##
##################################


def existingdir(x: str) -> Path:
    """
    Ensures an existing directory.
    """
    path = Path(x)

    if not (path.exists() and path.is_dir()):
        raise ValueError(f"{x} is not an existing directory.")

    return path


def compile_rules(rules: List[Dict[str, str]], prefix: str) -> List[Rule]:
    """
    Compiles copy rules.
    """
    return [
        Rule(re.compile(prefix + r["regex"]), r["filename"], r["directory"])
        for r in rules
    ]


def parse_cli_arguments() -> Config:
    """
    Parses and return arguments.
    """
    ## Define the parser:
    parser = argparse.ArgumentParser(
        prog=f"reforg",
        description="Organize files based on regular expressions",
        epilog=f"reforg -- v{__version__}",
    )

    ## Add specification file:
    parser.add_argument(
        "--spec",
        metavar="SPEC-FILE",
        required=True,
        type=argparse.FileType("r"),
        help="Specification file",
    )

    ## Add root firectory to clone files to:
    parser.add_argument(
        "--root",
        metavar="ROOT-DIR",
        required=True,
        type=existingdir,
        help="Root directory to copy processed files to",
    )

    ## Add dry-run:
    parser.add_argument(
        "--dry-run", action="store_true", help="Dry run (do not copy anything)"
    )

    ## Add flag to preserve metadata:
    parser.add_argument(
        "--metadata", action="store_true", help="Preserve metadata while copying"
    )

    ## Add flag to force copy:
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force copy if target exists (overwrite existing files)",
    )

    ## Add directories to traverse
    parser.add_argument(
        "dirs",
        metavar="DIR",
        type=existingdir,
        nargs="+",
        help=(
            "Directory to list files of to process. "
            "Note that special entries in the directory and sub-directories "
            "are not listed and therefore not processed."
        ),
    )

    ## Parse arguments:
    args = parser.parse_args()

    ## Load the spec file:
    spec = json.load(args.spec)

    ## Build config and return:
    return Config(
        rules=compile_rules(spec.get("rules", []), spec.get("prefix", "")),
        ignores=[re.compile(i) for i in spec.get("ignore", [])],
        root=args.root,
        force=args.force,
        metadata=args.metadata,
        dryrun=args.dry_run,
        dirs=args.dirs,
        terminal=sys.stdout.isatty(),
    )


###############
## WORKHORSE ##
###############


def classify(config: Config, path: Path) -> Optional[Path]:
    """
    Attempts to classify the given path as per given patterns.
    """
    ## Get and trim filename:
    filename = path.name

    ## Iterate over rules:
    for rule in config.rules:
        ## Attempt to match:
        match = rule.regex.match(filename)

        ## If we have a match, get groups, skip otherwise:
        if match:
            ## Yep, we have a match:
            groups = match.groupdict()

            ## Attempt to compile the target filename:
            try:
                newfilename = rule.template.format(**groups)
                directory = Path(rule.directory.format(**groups))
            except KeyError as err:
                print(err)
                print(path)
                raise err

            ## Build and return the target path:
            return config.root / directory / newfilename

    ## We do not have any match, return None:
    return None


def is_ignored(ignores: List[Pattern[str]], filename: str) -> bool:
    for ignore in ignores:
        if ignore.match(filename):
            return True
    return False


def traverse(config: Config) -> Iterable[Path]:
    """
    Traverses directories and yields paths of regular files.
    """
    for pdir in config.dirs:
        for path in (i for i in pdir.iterdir() if i.is_file()):
            if is_ignored(config.ignores, path.name):
                continue
            yield path


def print_term(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a terminal.
    """
    print(
        f"{TColor.WARNING}{status.name} {TColor.OKBLUE}{orig}{TColor.ENDC} -> {TColor.OKGREEN}{copy}{TColor.ENDC}"
    )


def print_nonterm(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a non-terminal.
    """
    print(f"{status.name} {orig} -> {copy}")


def copier(config: Config, orig: Path, copy: Path) -> None:
    """
    Attempts to copy the file.
    """
    if config.dryrun:
        status = Status.DRYRUN
    else:
        ## Get the copier function:
        copier = shutil.copy2 if config.metadata else shutil.copy

        ## Get the target parent directory:
        parent = copy.parent

        ## Create parent directory if it does not exist:
        parent.mkdir(parents=True, exist_ok=True)

        ## Check whether target exists, and copy accordingly:
        if copy.exists() and config.force:
            copier(str(orig), str(copy))
            status = Status.FORCED
        elif copy.exists():
            status = Status.EXISTS
        else:
            copier(str(orig), str(copy))
            status = Status.COPIED

    ## Log it:
    if config.terminal:
        print_term(orig, copy, status)
    else:
        print_nonterm(orig, copy, status)


################
## ENTRYPOINT ##
################


def main() -> None:
    """
    Entrypoint.
    """
    ## Parse config:
    config = parse_cli_arguments()

    ## Attempt to classify each path:
    for path in traverse(config):
        ## Attempt:
        attempt = classify(config, path)

        ## Success?
        if attempt is None:
            raise Exception(f"Path could not be classified. Filename: {path.name}")

        ## Copy:
        copier(config, path, attempt)


if __name__ == "__main__":
    main()
