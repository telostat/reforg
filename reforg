#!/usr/bin/env python3

import argparse
import csv
import re
import shutil
import sys
from enum import Enum, auto
from pathlib import Path
from typing import Iterable, List, NamedTuple, Optional, Pattern, Set, TextIO

#: Application version.
__version__ = "0.0.1.dev0"


######################
## DATA DEFINITIONS ##
######################


class Config(NamedTuple):
    """
    Program configuration.
    """

    #: Specifications.
    specs: List["Spec"]

    #: Ignored files.
    ignores: Set[str]

    #: Root directory.
    root: Path

    #: Preserve metadata?
    metadata: bool

    #: Force overwrite?
    force: bool

    #: Dry-run:
    dryrun: bool

    #: Directories to traverse:
    dirs: List[Path]

    #: Indicates if we are on a terminal:
    terminal: bool


class Spec(NamedTuple):
    """
    Pattern-Template specification.
    """

    #: Original filename pattern.
    pattern: Pattern

    #: Target filename template.
    template: str

    #: Sub directory for the target file.
    subdir: Path


class TColor:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


class Status(Enum):
    """
    Indicates the copy status.
    """

    DRYRUN = auto()
    EXISTS = auto()
    COPIED = auto()
    FORCED = auto()


##################################
## CLI ARGUMENTS PARSER HELPERS ##
##################################


def existingdir(x: str) -> Path:
    """
    Ensures an existing directory.
    """
    path = Path(x)

    if not (path.exists() and path.is_dir()):
        raise ValueError(f"{x} is not an existing directory.")

    return path


def compile_specs(cfile: TextIO, prefix: str) -> List[Spec]:
    """
    Reads given file and compiles specs.
    """
    return [
        Spec(re.compile(prefix + r["pattern"]), r["template"], Path(r["directory"]))
        for r in csv.DictReader(cfile)
    ]


def parse_cli_arguments() -> Config:
    """
    Parses and return arguments.
    """
    ## Define the parser:
    parser = argparse.ArgumentParser(prog="reforg")

    ## Add specification file:
    parser.add_argument(
        "--spec", required=True, type=argparse.FileType("r"), help="Specification file"
    )

    ## Add blacklist file:
    parser.add_argument(
        "--ignore",
        required=False,
        type=argparse.FileType("r"),
        help="Blacklist file (names of files to ignore)",
    )

    ## Add regex prefix:
    parser.add_argument(
        "--prefix",
        required=False,
        help="Regular expression prefix for all patterns in the specification file",
    )

    ## Add root firectory to clone files to:
    parser.add_argument(
        "--root",
        required=True,
        type=existingdir,
        help="Root directory to copy renamed files to",
    )

    ## Add dry-run:
    parser.add_argument("--dry-run", action="store_true", help="Dry run")

    ## Add flag to preserve metadata:
    parser.add_argument("--metadata", action="store_true", help="Preserve metadata")

    ## Add flag to force copy:
    parser.add_argument("--force", action="store_true", help="Force copy even if the target exists")

    ## Add directories to traverse
    parser.add_argument("dirs", metavar="DIRS", type=existingdir, nargs="+")

    ## Parse arguments:
    args = parser.parse_args()

    ## Compile specifications:
    specs = compile_specs(args.spec, args.prefix or "")

    ## Compile ignores set:
    ignores = args.ignore and set(i.strip() for i in args.ignore.readlines()) or set([])

    ## Build config and return:
    return Config(
        specs=specs,
        ignores=ignores,
        root=args.root,
        force=args.force,
        metadata=args.metadata,
        dryrun=args.dry_run,
        dirs=args.dirs,
        terminal=sys.stdout.isatty(),
    )


###############
## WORKHORSE ##
###############


def classify(parent: Path, specs: List[Spec], path: Path) -> Optional[Path]:
    """
    Attempts to classify the given path as per given patterns.
    """
    ## Get and trim filename:
    filename = path.name.strip()

    ## Iterate over specs:
    for spec in specs:
        ## Attempt to match:
        match = spec.pattern.match(filename)

        ## If we have a match, get groups, skip otherwise:
        if match:
            ## Yep, we have a match:
            groups = match.groupdict()

            ## Attempt to compile the target filename:
            try:
                newfilename = spec.template.format(**groups)
            except KeyError as err:
                print(err)
                print(path)

            ## Build and return the target path:
            return parent / spec.subdir / newfilename

    ## We do not have any match, return None:
    return None


def traverse(config: Config) -> Iterable[Path]:
    """
    Traverses directories and yields paths of regular files.
    """
    for pdir in config.dirs:
        for path in (i for i in pdir.iterdir() if i.is_file()):
            if path.name in config.ignores:
                continue
            yield path


def print_term(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a terminal.
    """
    print(f"{TColor.WARNING}{status.name} {TColor.OKBLUE}{orig}{TColor.ENDC} -> {TColor.OKGREEN}{copy}{TColor.ENDC}")


def print_nonterm(orig: Path, copy: Path, status: Status) -> None:
    """
    Print operation on a non-terminal.
    """
    print(f"{status.name} {orig} -> {copy}")


def copier(config: Config, orig: Path, copy: Path) -> None:
    """
    Attempts to copy the file.
    """
    if config.dryrun:
        status = Status.DRYRUN
    else:
        ## Get the copier function:
        copier = shutil.copy2 if config.metadata else shutil.copy

        ## Get the target parent directory:
        parent = copy.parent

        ## Create parent directory if it does not exist:
        parent.mkdir(parents=True, exist_ok=True)

        ## Check whether target exists, and copy accordingly:
        if copy.exists() and config.force:
            copier(str(orig), str(copy))
            status = Status.FORCED
        elif copy.exists():
            status = Status.EXISTS
        else:
            copier(str(orig), str(copy))
            status = Status.COPIED

    ## Log it:
    if config.terminal:
        print_term(orig, copy, status)
    else:
        print_nonterm(orig, copy, status)


################
## ENTRYPOINT ##
################


def main() -> None:
    """
    Entrypoint.
    """
    ## Parse config:
    config = parse_cli_arguments()

    ## Print function:
    printer = print_term if config.terminal else print_nonterm

    ## Copy function:
    
    ## Attempt to classify each path:
    for path in traverse(config):
        ## Attempt:
        attempt = classify(config.root, config.specs, path)

        ## Success?
        if attempt is None:
            raise Exception(f"Path could not be classified. Filename: {path.name}")

        ## Copy:
        copier(config, path, attempt)


if __name__ == "__main__":
    main()
